-- -------------------------------------------------------------
--
-- file name: hdl_prj\hdlsrc\fifoirqctrl\axi_fifo_irq_ctrl_if.vhd
-- created: 2015-05-11 16:51:30
--
-- generated by matlab 9.0 and hdl coder 3.7
--
--
-- -------------------------------------------------------------
-- rate and clocking details
-- -------------------------------------------------------------
-- model base rate: 0.2
-- target subsystem base rate: 0.2
--
-- -------------------------------------------------------------


-- -------------------------------------------------------------
--
-- module: axi_fifo_irq_ctrl_if
-- source path: fifoirqctrl/axi_fifo_irq_ctrl_if
-- hierarchy level: 0
--
-- -------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;


entity axi_fifo_irq_ctrl_if is
  generic(
        --base_addr      : in std_logic_vector(31 DOWNTO 0) := X"43c50000"
        base_addr      : in integer := 1137049600 -- X"43c60000"
  );
  port(
         -- axi interface signals
        axi_clk             : in std_logic;
        axi_rst             : in std_logic;
        axi_awaddr          : in std_logic_vector(31 downto 0);
        axi_wvalid          : in std_logic;
        axi_awvalid         : in std_logic;
        axi_wdata           : in std_logic_vector(31 downto 0);
        data_clk            : in std_logic;
        axis_tvalid         : in std_logic;
        enable              : in std_logic;
        fifo_of             : in std_logic;
        fifo_uf             : in std_logic;
        wr_ctrl             : in std_logic_vector(31 downto 0);
        wr_isr              : in std_logic_vector(31 downto 0);
        wr_ier              : in std_logic_vector(31 downto 0);
        fifo_data_occ_cnt   : in std_logic_vector(4 downto 0);
        data_path_rst       : in std_logic;
        rd_status           : out std_logic_vector(31 downto 0);
        rd_isr              : out std_logic_vector(31 downto 0);
        rd_ier              : out std_logic_vector(31 downto 0);
        rd_ofcnt            : out std_logic_vector(31 downto 0);
        rd_ufcnt            : out std_logic_vector(31 downto 0);
        rd_fifo_occ_cnt     : out std_logic_vector(31 downto 0);
        rd_fifo_samp_cnt    : out std_logic_vector(31 downto 0);  -- uint32
        ext_irq             : out std_logic  -- ufix1
        );
end axi_fifo_irq_ctrl_if;


architecture rtl of axi_fifo_irq_ctrl_if is

  -- component declarations

  -- component configuration statements

  -- registers/signals
  constant ctrl_reg_addr      : std_logic_vector(31 downto 0) := std_logic_vector(to_unsigned(base_addr, 32)) OR X"00000100";--base_addr OR  X"00000100";
  constant isr_reg_addr       : std_logic_vector(31 downto 0) := std_logic_vector(to_unsigned(base_addr, 32)) OR X"00000108";--base_addr OR  X"00000104";

  signal tvalid_arm             : std_logic;
  signal tvalid_sig             : std_logic;
  signal underflow_cnt          : unsigned(31 downto 0);
  signal overflow_cnt           : unsigned(31 downto 0);
  signal fifo_samp_cnt          : unsigned(31 downto 0);
  signal reset                  : std_logic;
  signal reset_shft             : std_logic_vector(7 downto 0);
  signal fifo_uf_reg            : std_logic;
  signal fifo_of_reg            : std_logic;
  signal uf_int_clr             : std_logic;
  signal of_int_clr             : std_logic;
  signal status_int             : std_logic_vector(31 downto 0);
  signal status_int_sync1       : std_logic_vector(31 downto 0);
  signal status_int_sync2       : std_logic_vector(31 downto 0);
  signal isr_int                : std_logic_vector(31 downto 0);
  signal isr_int_sync1          : std_logic_vector(31 downto 0);
  signal isr_int_sync2          : std_logic_vector(31 downto 0);
  signal ier_int                : std_logic_vector(31 downto 0);
  signal ier_int_sync1          : std_logic_vector(31 downto 0);
  signal ier_int_sync2          : std_logic_vector(31 downto 0);
  signal rst_reg                : std_logic;
  signal rst_clr                : std_logic;
  signal uf_int_reg             : std_logic;
  signal uf_clr                 : std_logic;
  signal uf_int_shft            : std_logic_vector(7 downto 0);
  signal of_int_reg             : std_logic;
  signal of_clr                 : std_logic;
  signal of_int_shft            : std_logic_vector(7 downto 0);
  signal rd_ofcnt_sync1         : std_logic_vector(31 downto 0);
  signal rd_ofcnt_sync2         : std_logic_vector(31 downto 0);
  signal rd_ufcnt_sync1         : std_logic_vector(31 downto 0);
  signal rd_ufcnt_sync2         : std_logic_vector(31 downto 0);
  signal fifo_occ_cnt_sync1     : std_logic_vector(4 downto 0);
  signal fifo_occ_cnt_sync2     : std_logic_vector(4 downto 0);
  signal fifo_samp_cnt_sync1    : std_logic_vector(31 downto 0);
  signal fifo_samp_cnt_sync2    : std_logic_vector(31 downto 0);
  signal enable_int             : std_logic;
  signal ctrl_int               : std_logic_vector(31 downto 0);
  signal ctrl_int_sync1         : std_logic_vector(31 downto 0);
  signal ctrl_int_sync2         : std_logic_vector(31 downto 0);
  signal enb_sel                : std_logic_vector(1 downto 0);

begin

--------------------------------------------------------
-- Enable logic --
enb_sel <= ctrl_int(2 downto 1);
process (data_clk, reset, enb_sel, enable, tvalid_arm)
begin
    if rising_edge(data_clk) then
        if reset = '1' then 
            enable_int <= '0';
        else 
            case ENB_SEL is
                when "00" => -- disable core
                    ENABLE_int <= '0';
                when "01" => -- internally enabled i.e. on all the time
                    ENABLE_int <= '1';
                when "10" => -- enabled using external enable port only
                    ENABLE_int <= enable;
                when "11" => -- enabled using
                    ENABLE_int <= enable and tvalid_arm;
                when others =>
                    -- do nothing
            end case;
        end if;
    end if;
end process;
--------------------------------------------------------

-- one shot tvalid capture
process (DATA_CLK,ENABLE,data_path_rst,axis_tvalid)
begin
if rising_edge(DATA_CLK) then
    if data_path_rst = '1' or reset = '1' then -- data_path_rst is synchronous to DATA_CLK
        tvalid_sig <= '1';
        tvalid_arm <= '0';
    elsif axis_tvalid = '1' and ENABLE = '1' and tvalid_sig = '1' then
        tvalid_sig <= '0';
        tvalid_arm <= '1';
    end if;
end if;
end process;

-- count valid overflow events
process (DATA_CLK, reset, fifo_of, ENABLE_int)
begin
if rising_edge(DATA_CLK) then
    if reset = '1' then
        overflow_cnt <= (others=>'0');
    elsif fifo_of = '1' and ENABLE_int = '1'  then
        overflow_cnt <= overflow_cnt + 1;
    end if;
end if;
end process;

-- count valid underflow events
process (DATA_CLK, reset, fifo_uf, ENABLE_int)
begin
if rising_edge(DATA_CLK) then
    if reset = '1' then
        underflow_cnt <= (others=>'0');
    elsif fifo_uf = '1' and ENABLE_int = '1' then
        underflow_cnt <= underflow_cnt + 1;
    end if;
end if;
end process;

-- register underflow interrupt using ENABLE_int
process (reset,DATA_CLK,fifo_uf,ENABLE_int,uf_int_clr)
begin
if rising_edge(DATA_CLK) then
    if reset = '1' or uf_int_clr = '1' then
        fifo_uf_reg <= '0';
    elsif fifo_uf = '1' and ENABLE_int = '1' then
        fifo_uf_reg <= '1';
    end if;
end if;
end process;

-- register overflow interrupt using ENABLE_int
process (reset,DATA_CLK,fifo_of,ENABLE_int)
begin
if rising_edge(DATA_CLK) then
    if reset = '1' or of_int_clr = '1' then
        fifo_of_reg <= '0';
    elsif fifo_of = '1' and ENABLE_int = '1' then
        fifo_of_reg <= '1';
    end if;
end if;
end process;

-- count number of samples that have passed through detection FIFO
process(reset, DATA_CLK, AXIS_TVALID, ENABLE_int)
begin
if rising_edge(DATA_CLK) then
    if reset = '1' then
        fifo_samp_cnt <= (others=>'0');
    elsif AXIS_TVALID = '1' and ENABLE_int = '1' then
        fifo_samp_cnt <= fifo_samp_cnt + 1;
    end if;
end if;
end process;

-- register tvalid fired
status_int <= (0 => enable_int, 1 => enb_sel(0) , 2 => enb_sel(1), others => '0');

-- register underflow/overflow interrupt event
isr_int <= (0 => fifo_uf_reg, 1 => fifo_of_reg, others => '0');

-- trigger external interrupt signal
ext_irq <= or_reduce(ier_int and isr_int);

-- register write to ISR
process(axi_clk, axi_rst,axi_awvalid,axi_wvalid,axi_wdata)
begin
if rising_edge(axi_clk) then
  if axi_rst = '1' then
        rst_reg <= '0';
        uf_int_reg <= '0';
        of_int_reg <= '0';
  else
        if (axi_awvalid = '1' and axi_wvalid = '1') then
            case axi_awaddr is
                when ctrl_reg_addr =>
                    rst_reg <= axi_wdata(0);--wr_ctrl(0);
                when isr_reg_addr =>
                    uf_int_reg  <= axi_wdata(0);--wr_isr(0);
                    of_int_reg  <= axi_wdata(1);--wr_isr(1);
                when others =>
                    -- do nothing
            end case;
        else
            if rst_clr = '1' then
                rst_reg <= '0';
            end if;

            if uf_clr = '1' then
                uf_int_reg <= '0';
            end if;

            if of_clr = '1' then
                of_int_reg <= '0';
            end if;
        end if;
  end if;
end if;
end process;

rst_proc : process (DATA_CLK)
begin
    if rising_edge(DATA_CLK) then
        if rst_reg = '0' then
            rst_clr    <= '0';
            reset_shft <= reset_shft (6 downto 0) & '0';
        else
            reset_shft <= (others => '1');
            rst_clr    <= '1';
        end if;

        if uf_int_reg = '0' then
            uf_clr    <= '0';
            uf_int_shft <= uf_int_shft (6 downto 0) & '0';
        else
            uf_int_shft <= (others => '1');
            uf_clr    <= '1';
        end if;

        if of_int_reg = '0' then
            of_clr    <= '0';
            of_int_shft <= of_int_shft (6 downto 0) & '0';
        else
            of_int_shft <= (others => '1');
            of_clr    <= '1';
        end if;
    end if;
end process rst_proc;


reset <= reset_shft(7);
uf_int_clr <= uf_int_shft(7);
of_int_clr <= of_int_shft(7);

-- sync to DATA_CLK
s_axis_sync_process : process(DATA_CLK)
begin
    if rising_edge(DATA_CLK) then
        ier_int_sync1 <= wr_ier;
        ier_int_sync2 <= ier_int_sync1;
        ier_int <= ier_int_sync2;
        
        ctrl_int_sync1 <= wr_ctrl;
        ctrl_int_sync2 <= ctrl_int_sync1;
        ctrl_int <= ctrl_int_sync2;

    end if;
end process s_axis_sync_process;

--sync to axi_lite_clk
process(axi_clk)
begin
if rising_edge(axi_clk) then
    if axi_rst = '1' then
        status_int_sync1 <= (others => '0');
        status_int_sync2 <= (others => '0');

        isr_int_sync1 <= (others => '0');
        isr_int_sync2 <= (others => '0');

        rd_ofcnt_sync1 <= (others => '0');
        rd_ofcnt_sync2 <= (others => '0');

        rd_ufcnt_sync1 <= (others => '0');
        rd_ufcnt_sync2 <= (others => '0');

        fifo_occ_cnt_sync1 <= (others => '0');
        fifo_occ_cnt_sync2 <= (others => '0');

        fifo_samp_cnt_sync1 <= (others => '0');
        fifo_samp_cnt_sync2 <= (others => '0');

    else
        status_int_sync1 <= status_int;
        status_int_sync2 <= status_int_sync1;
        rd_status <= status_int_sync2;

        isr_int_sync1 <= isr_int;
        isr_int_sync2 <= isr_int_sync1;
        rd_isr <= isr_int_sync2;

        rd_ofcnt_sync1 <= std_logic_vector(overflow_cnt);
        rd_ofcnt_sync2 <= rd_ofcnt_sync1;
        rd_ofcnt <= rd_ofcnt_sync2;

        rd_ufcnt_sync1 <= std_logic_vector(underflow_cnt);
        rd_ufcnt_sync2 <= rd_ufcnt_sync1;
        rd_ufcnt <= rd_ufcnt_sync2;

        fifo_occ_cnt_sync1 <= fifo_data_occ_cnt;
        fifo_occ_cnt_sync2 <= fifo_occ_cnt_sync1;
        rd_fifo_occ_cnt(4 downto 0) <= fifo_occ_cnt_sync2;
        rd_fifo_occ_cnt(31 downto 5) <= (others=>'0');

        fifo_samp_cnt_sync1 <= std_logic_vector(fifo_samp_cnt);
        fifo_samp_cnt_sync2 <= fifo_samp_cnt_sync1;
        rd_fifo_samp_cnt <= fifo_samp_cnt_sync2;
    end if;
end if;
end process;

rd_ier <= wr_ier;

end rtl;

