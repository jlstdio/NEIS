-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\axi_lite_sample_counter\axi_lite_sample_counter.vhd
-- Created: 2014-07-01 14:40:57
-- 
-- Generated by MATLAB 8.4 and HDL Coder 3.5
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 0.2
-- Target subsystem base rate: 0.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: axi_lite_sample_counter
-- Source Path: axi_lite_sample_counter/axi_lite_sample_counter
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY axi_lite_sample_counter IS
  PORT( -- axi lite interface
        aclk                : in std_logic;
        aresetn             : in std_logic;
        axi_awaddr          : in std_logic_vector(31 downto 0);
        axi_wvalid          : in std_logic;
        axi_awvalid         : in std_logic;
        axi_wdata           : in std_logic_vector(31 downto 0);
        
        ps7_fclk0           : in std_logic;
        data_path_rst_n     : in std_logic;
        -- axi stream interface
        s_axis_tvalid       : in std_logic;
        s_axis_tready       : out std_logic;
        s_axis_tdata        : in std_logic_vector(63 downto 0);
        m_axis_tvalid       : out std_logic;
        m_axis_tready       : in std_logic;
        m_axis_tdata        : out std_logic_vector(63 downto 0);
        m_axis_tlast        : out std_logic;
        -- debug
        debug_out           : out std_logic_vector(34 downto 0);
        -- registers
        wr_samples_per_ring : in std_logic_vector(31 downto 0);
        rd_samples_per_ring : out std_logic_vector(31 downto 0);
        wr_rst_reg          : in std_logic_vector(31 downto 0);
        rd_rst_reg          : out std_logic_vector(31 downto 0);
        
        rst_out             : out std_logic 
        );
END axi_lite_sample_counter;





ARCHITECTURE rtl OF axi_lite_sample_counter IS

 signal sample_cnt : unsigned(31 downto 0);
 signal tlast_int : std_logic;
 signal samples_per_ring : integer;
 
 constant rst_reg_addr   : std_logic_vector(31 downto 0) := x"50000104";--fix me!!!
 signal rst_reg          : std_logic;
 signal rst_reg_shift    : std_logic_vector(19 downto 0);
 signal rst_reg_clr      : std_logic;
 
 signal samples_per_ring_sync1 : std_logic_vector(31 downto 0);
 signal samples_per_ring_sync2 : std_logic_vector(31 downto 0);
 signal samples_per_ring_sync3 : std_logic_vector(31 downto 0);

BEGIN
    m_axis_tvalid   <= s_axis_tvalid;       -- pass through
    m_axis_tdata    <= s_axis_tdata;        -- pass through
    s_axis_tready   <= m_axis_tready;       -- pass through
    
    m_axis_tlast <= tlast_int;
    
    debug_out <= s_axis_tvalid & m_axis_tready & tlast_int & std_logic_vector(sample_cnt); 
    
    gen_tlast : process(ps7_fclk0, data_path_rst_n, s_axis_tvalid, samples_per_ring_sync3, rst_reg_shift) is
    begin
        if (data_path_rst_n = '0' or rst_reg_shift(19) = '1') then
            sample_cnt <= (others => '0');
            tlast_int <= '0';
            samples_per_ring <= to_integer(unsigned(samples_per_ring_sync3));
        elsif rising_edge(ps7_fclk0) then
            if ((s_axis_tvalid = '1') and (m_axis_tready = '1') ) then    
                if (sample_cnt = samples_per_ring - 2) then
                    sample_cnt  <= sample_cnt + 1;
                    tlast_int <= '1';
                elsif (sample_cnt = samples_per_ring - 1) then
                    sample_cnt <= (others => '0');
                    tlast_int <= '0';
                elsif (sample_cnt < samples_per_ring) then
                    sample_cnt <= sample_cnt + 1;
                    tlast_int <= '0';
                end if;                
            end if;
        end if;
    end process;
    
    process(aclk, aresetn)
       begin
       if aclk'event and aclk = '1' then
         if aresetn = '0' then
               rst_reg <= '0';
         else
               if (axi_awvalid = '1' and axi_wvalid = '1') then
                   case axi_awaddr is
                       when rst_reg_addr =>
                           rst_reg <= '1';--axi_wdata(1);
                       when others =>
                           -- do nothing
                   end case;
               else
                   if rst_reg_clr = '1' then
                       rst_reg <= '0';
                   end if;
               end if;
         end if;
       end if;
    end process;
       
    rst_proc : process (aclk)
    begin
    if aclk'event and aclk = '1' then
       if rst_reg = '0' then
           rst_reg_clr    <= '0';
           rst_reg_shift   <= rst_reg_shift (18 downto 0) & '0';
       else
           rst_reg_shift   <= (others => '1');
           rst_reg_clr    <= '1';
       end if;
    end if;
    end process rst_proc;
    
    -- sync samples_per_ring_reg to axi stream clock domain
   sync_proc : process(ps7_fclk0)
     begin
        if rising_edge(ps7_fclk0) then
            -- sync axi register write for sample count value
            samples_per_ring_sync1 <= wr_samples_per_ring;
            samples_per_ring_sync2 <= samples_per_ring_sync1;
            if samples_per_ring_sync2 = samples_per_ring_sync1 then
                samples_per_ring_sync3 <= samples_per_ring_sync2;
            end if;
        end if;
     end process sync_proc;

   rd_samples_per_ring <= samples_per_ring_sync3;
   rd_rst_reg <= (wr_rst_reg(31 downto 1) & rst_reg_shift(19));
   
   rst_out <= rst_reg_shift(19);


END rtl;

